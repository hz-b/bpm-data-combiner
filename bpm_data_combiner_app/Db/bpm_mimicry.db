record(ao, "$(PREFIX):par:mls:conv:x")
{
    field(DESC, "double to bit conversion factor")
    # classic BPM system
    # 16 bit for -10..10 V
    # for BESSY II
    # 1 V per mm
    # cross checks for MLS indicate
    # 2/3 V per mm
    #
    # libera boxes
    # use nm
    # value for BESSY II
    field(VAL, "3276.8e-6")
    # value for MLS multiply with 1/1.5
    field(VAL, "2184.533e-6")
    field(PINI, "YES")
}

record(ao, "$(PREFIX):par:mls:conv:y")
{
    field(DESC, "double to bit conversion factor")
    # classic BPM system
    # 16 bit for -10..10 V
    # for BESSY II
    # 1 V per mm
    # cross checks for MLS indicate
    # 2/3 V per mm
    #
    # libera boxes
    # use nm
    # value for BESSY II
    # value for MLS seems to be x
    field(VAL, "3276.8e-6")
    field(PINI, "YES")
}

# need to scale data so that BPM readings accepts data?
record(ao, "$(PREFIX):par:scale_std")
{
    field(DESC, "scale factor for std")
    field(VAL, "1")
    field(PINI, "YES")
}

# scale libera nm to classic bits
record(pycalc, "$(PREFIX):im:x:values")
{
    field(INPA, "$(PREFIX):out:2s:x:values CPP")
    field(INPB, "$(PREFIX):par:mls:conv:x")
    field(FTA, "LONG")
    field(FTB, "DOUBLE")
    field(CALC, "recalculate_value(value=A, nm2bits=B)")
    field(FTVL, "SHORT")
    field(MEVL, 128)
}


# scale libera nm to classic bits
record(pycalc, "$(PREFIX):im:y:values")
{
    field(INPA, "$(PREFIX):out:2s:y:values CPP")
    field(INPB, "$(PREFIX):par:mls:conv:y")
    field(FTA, "LONG")
    field(FTB, "DOUBLE")
    field(CALC, "recalculate_value(value=A, nm2bits=B)")
    field(FTVL, "SHORT")
    field(MEVL, 128)
}


# scale libera nm to classic bits
record(pycalc, "$(PREFIX):im:x:std")
{
    field(INPA, "$(PREFIX):out:2s:x:std CPP")
    field(INPB, "$(PREFIX):par:mls:conv:x")
    field(FTA, "LONG")
    field(FTB, "DOUBLE")
    field(INPC, "$(PREFIX):par:scale_std")
    field(CALC, "recalculate_value(value=A, nm2bits=B, scale=C)")
    field(FTVL, "SHORT")
    field(MEVL, 128)
}

# scale libera nm to classic bits
record(pycalc, "$(PREFIX):im:y:std")
{
    field(INPA, "$(PREFIX):out:2s:y:std CPP")
    field(INPB, "$(PREFIX):par:mls:conv:y")
    field(INPC, "$(PREFIX):par:scale_std")
    field(FTA, "LONG")
    field(FTB, "DOUBLE")
    field(CALC, "recalculate_value(value=A, nm2bits=B, scale=C)")
    field(FTVL, "SHORT")
    field(MEVL, 128)
    # assuming that this data is the last one produced by the
    # the combiner
    field(FLNK, "$(PREFIX):im:rdBufBpm")
}


# currently only a single index.
# let's make it a waveform as soon as more BPM's are to be used
record(longin, "$(PREFIX):par:index")
{
    field(DESC, "insert libera readings at this place")
    field(VAL, "27")
    field(PINI, "YES")
}



# add data at correct position into array
record(pycalc, "$(PREFIX):im:rdBufBpm")
{
    # the combiner is triggered by this data
    # so being triggered on the other data should do the job
    field(DESC, "insert libera data at proper place")
    field(INPA, "BPMZ1X003GP:rdBufBpm")
    field(MEA, 256)
    field(FTA, "SHORT")
    field(INPB, "$(PREFIX):im:x:values")
    field(FTB, "SHORT")
    field(INPC, "$(PREFIX):im:x:std")
    field(FTC, "SHORT")
    field(INPD, "$(PREFIX):im:y:values")
    field(FTD, "SHORT")
    # assuming that this data is the last one produced by the
    # the combiner
    field(INPE, "$(PREFIX):im:y:std")
    field(FTE, "SHORT")
    field(INPF, "$(PREFIX):par:index")
    field(FTF, "LONG")
    field(CALC, "insert(data=A, x=(B,C), y=(D,E), index=F, active=True, verbose=%TPRO%)")
    field(FTVL, "SHORT")
    field(MEVL, "256")

    field(TPRO, 0)
    # field(FLNK, "BPMZ1X013GP:rdBufBpm")
}


# why can I not read the data directly from pydev
record(waveform, "BPMZ1X013GP:rdBufBpm")
{
    field(DESC, "Proxy output")
    field(DTYP, "pydev")
    # field(INP, "$(PREFIX):im:rdBufBpm")
    field(SCAN, "I/O Intr")
    field(INP,  "@pydev.iointr('scaled-bpm-data')")
    field(NELM, "256")
    field(FTVL, "SHORT")
}